/**
 * User: garcia.wul (garcia.wul@alibaba-inc.com)
 * Date: 13-8-15
 * Time: 上午9:32
 *
 */

var EventEmitter = require('events').EventEmitter;
var fs = require("fs");
var path = require("path");
var util = require('util');
var makeError = require('makeerror');
var ncp = require('ncp').ncp;

var filesystem = {};

/**
 * 异步递归地创建目录
 * @param directoryName
 * @param mode 缺省是 `0777 & (~process.umask())`
 * @param callback 函数原型是：callback(error, made) error是有错误时的错误信息;made是被创建的第一级目录
 * @param made
 * 参考自：https://github.com/substack/node-mkdirp
 */
filesystem.makedirs = function(directoryName, mode, callback, made) {
    if (typeof mode === "function" || typeof mode === "undefined") {
        callback = mode;
        mode = 0777 & (~process.umask());
    }
    if (typeof callback !== "function") {
        callback = function() {};
    }
    if (typeof mode === "string") {
        mode = parseInt(mode, 8);
    }
    if (!made) {
        made = null;
    }
    directoryName = path.resolve(directoryName);
    fs.mkdir(directoryName, mode, function(error) {
        if (!error) {
            made = made || directoryName;
            return callback(null, made);
        }
        if (error.code === "ENOENT") {
            filesystem.makedirs(path.dirname(directoryName), mode, function(error, made) {
                if (error) {
                    callback(error, made);
                }
                else {
                    filesystem.makedirs(directoryName, mode, callback, made);
                }
            });
        }
        // 这种情况，目录可能已经存在；或者其他未知的问题
        else {
            fs.stat(directoryName, function(error, stat) {
                if (error || !stat.isDirectory()) {
                    callback(error, made);
                }
                else {
                    callback(null, made);
                }
            });
        }

    });

};

/**
 * makedirs的同步实现
 * @param directoryName
 * @param mode
 * @param made
 * @returns {*}
 */
filesystem.makedirsSync = function(directoryName, mode, made) {
    if (typeof mode === "undefined") {
        mode = 0777 & (~process.umask());
    }
    else if (typeof mode === "string") {
        mode = parseInt(mode, 8);
    }
    if (!made) {
        made = null;
    }

    directoryName = path.resolve(directoryName);
    try {
        fs.mkdirSync(directoryName, mode);
        made = made || directoryName;
    }
    catch (error0) {
        if (error0.code === "ENOENT") {
            made = filesystem.makedirsSync(path.dirname(directoryName), mode, made);
            filesystem.makedirsSync(directoryName, mode, made);
        }
        else {
            var stat = null;
            try {
                stat = fs.statSync(directoryName);
            }
            catch(error1) {
                throw error1;
            }
            if (!stat.isDirectory()) {
                throw  error0;
            }
        }
    }
    return made;
};

/**
 * 对指定的目录walk,参考：https://github.com/daaku/nodejs-walker
 * @param root
 * @returns {filesystem.Walker}
 * @constructor
 * 使用:
 * var walker = Walker('/etc/');
 * walker.on("entry", function(entry, stat) {});
 * walker.on("file", function(entry, stat) {});
 */
filesystem.Walker = function(root) {
    if (!this instanceof filesystem.Walker) {
        return new filesystem.Walker(root);
    }
    EventEmitter.call(this);
    this.pending = 0;
    this.go(root);
};
util.inherits(filesystem.Walker, EventEmitter);

filesystem.Walker.prototype.go = function(entry) {
    var self = this;
    this.pending ++;
    fs.lstat(entry, function(error, stat) {
        if (error) {
            self.emit("error", error, entry, stat);
            self.doneOne();
            return;
        }
        if (stat.isDirectory()) {
            fs.readdir(entry, function(error, files) {
                if (error) {
                    self.emit("error", error, entry, stat);
                    self.doneOne();
                    return;
                }
                self.emit("entry", entry, stat);
                self.emit("dir", entry, stat);
                files.forEach(function(part) {
                    self.go(path.join(entry, part));
                });
                self.doneOne();
            });
        }
        else if (stat.isSymbolicLink()) {
            self.emit("entry", entry, stat);
            self.emit("dir", entry, stat);
            self.doneOne();
        }
        else if (stat.isBlockDevice()) {
            self.emit("entry", entry, stat);
            self.emit("blockDevice", entry, stat);
            self.doneOne();
        }
        else if (stat.isCharacterDevice()) {
            self.emit("entry", entry, stat);
            self.emit("characterDevice", entry, stat);
            self.doneOne();
        }
        else if (stat.isFIFO()) {
            self.emit("entry", entry, stat);
            self.emit("fifo", entry, stat);
            self.doneOne();
        }
        else if (stat.isSocket()) {
            self.emit("entry", entry, stat);
            self.emit("socket", entry, stat);
            self.doneOne();
        }
        else if (stat.isFile()) {
            self.emit("entry", entry, stat);
            self.emit("file", entry, stat);
            self.doneOne();
        }
        else {
            self.emit('error', makeError(
                "UnknownFileTypeError",
                "The type of this file could not be determined."
            )(), entry, stat);
            self.doneOne();
        }
    });
    return this;
};

filesystem.Walker.prototype.doneOne = function() {
    -- this.pending;
    if (this.pending === 0) {
        this.emit("end");
    }
    return this;
};

/**
 * 列出这个目录下所有的文件(同步地)
 * @param root
 * @returns {Array}
 */
filesystem.listTreeSync = function(root) {
    var files = [];
    var parts = fs.readdirSync(root);
    parts.forEach(function(part) {
        part = path.join(root, part);
        if (fs.statSync(part).isDirectory()) {
            filesystem.listTreeSync(part).forEach(function(file) {
                files.push(file);
            });
        }
        else {
            files.push(part);
        }
    });
    return files;
};

/**
 *异步拷贝文件或者目录，支持递归
 * @param sourceFile
 * @param destFile
 * @param callback 函数原型callback(error)
 */
filesystem.copy = function(sourceFile, destFile, callback) {
    if (typeof callback !== "function") {
        callback = function() {};
    }
    ncp(sourceFile, destFile, callback);
};

filesystem.copySync = function(sourceFile, destFile) {
    if (!fs.existsSync(path.dirname(destFile))) {
         throw util.format("%s not exist", path.dirname(destFile));
    }

    if (fs.statSync(sourceFile).isDirectory()) {
        if (fs.existsSync(destFile)) {
            if (fs.statSync(destFile).isDirectory()) {
                copyDirToDir(sourceFile, path.join(
                    destFile, path.basename(sourceFile)));
            }
            else {
                throw util.format("cannot copy directory to file");
            }
        }
        else {
            copyDirToDir(sourceFile, destFile);
        }
    }
    else if (fs.statSync(sourceFile).isFile()) {
        if (fs.existsSync(destFile) && fs.statSync(destFile).isDirectory()) {
            copyFileToFile(sourceFile, path.join(
                destFile, path.basename(sourceFile)
            ));
        }
        else {
            copyFileToFile(sourceFile, destFile);
        }
    }
    else {
        throw util.format("%s is not directory or file", sourceFile);
    }

    function copyFileToFile(sourceFile, destFile) {
        copyFileSync(sourceFile, destFile);
    }

    function copyDirToDir(sourceFile, destFile) {
        if (!fs.existsSync(destFile)) {
            fs.mkdirSync(destFile);
        }
        fs.readdirSync(sourceFile).forEach(function(file) {
            if (fs.statSync(path.join(sourceFile, file)).isFile()) {
                copyFileSync(path.join(sourceFile, file), path.join(
                    destFile, file
                ));
            }
            else if (fs.statSync(path.join(sourceFile, file)).isDirectory()) {
                copyDirToDir(path.join(sourceFile, file),
                    path.join(destFile, file));
            }
        });
    }
};

/**
 * 同步地拷贝文件,不支持目录和递归
 * @param sourceFile 源文件
 * @param destFile 目标文件
 */
function copyFileSync(sourceFile, destFile) {
    var BUF_LENGTH, buff, bytesRead, fdr, fdw, pos;
    BUF_LENGTH = 64 * 1024;
    buff = new Buffer(BUF_LENGTH);
    fdr = fs.openSync(sourceFile, "r");
    fdw = fs.openSync(destFile, "w");
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
    bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
    fs.writeSync(fdw, buff, 0, bytesRead);
        pos += bytesRead;
    }
    fs.closeSync(fdr);
    return fs.closeSync(fdw)
}

module.exports = filesystem;