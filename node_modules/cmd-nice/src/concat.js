/**
 * User: Wu Liang 
 * Date: 2014/05/26
 * Time: 16:29
 * 对transport后的文件进行合并
 */

var fs = require('fs');
var path = require("path");
var util = require("util");

var _ = require("underscore");
var StringUtils = require("underscore.string");
var Handlebars = require("handlebars");

var Base = require("./base");
var CmdParser = require("./utils/cmd-parser");
var Q = require("q");
var extend = require("extend");

/**
 * 构造函数
 * @param options 所包含的字段有：
 * * filters: 是否使用过滤功能，默认false; 可以传入一个数组，来过滤相应的后缀名; 也可以是一个函数，来自定义过滤;
 * * include: 打包策略; relative/all/self
 * * separator: 合并文件的分隔，默认;
 * @constructor
 */
var Concat = function(options) {
    var self = this;
    self.options = {};
    Base.call(self, options);
    // 保存id和内容的对应
    self.idCache = {};
    self.astCache = {};
    self.dependenciesCache = {};
};
util.inherits(Concat, Base);

Concat.prototype.execute = function(inputFile) {
    var self = this;
    var deferred = Q.defer();
    var content = inputFile.content;
    var source = inputFile.src;

    // Step 1: 得到抽象语法树
    var cmdParser = new CmdParser();
    var ast = null;
    var metaAst = null;
    if (self.options.useCache && _.has(self.astCache, source) && self.astCache[source].ast) {
        ast = self.astCache[source].ast;
    }
    else {
        ast = cmdParser.getAst(content);
        if (!ast) {
            process.nextTick(function() {
                deferred.reject({
                    message: Handlebars.compile("parse {{{source}}} failed")({
                        source: source
                    }),
                    level: "error"
                });
            });
            return deferred.promise;
        }
        if (ast.error === true) {
            process.nextTick(function() {
                deferred.reject({
                    message: Handlebars.compile("parse {{{source}}} ast failed: {{{line}}},{{{col}}}")({
                        source: source,
                        line: ast.line,
                        col: ast.col
                    }),
                    level: "error"
                });
            });
            return deferred.promise;
        }
    }

    if (self.options.useCache && _.has(self.astCache, source) && self.astCache[source].metaAst) {
        metaAst = self.astCache[source].metaAst;
    }
    else {
        metaAst = cmdParser.parseFirst(ast);
        if (metaAst && self.options.useCache) {
            self.astCache[source] = {
                ast: ast,
                metaAst: metaAst
            };
        }
    }

    if (!metaAst) {
        process.nextTick(function() {
            deferred.reject({
                level: "warn",
                message: Handlebars.compile("{{{source}}} is not CMD format")({
                    source: source
                })
            });
        });
        return deferred.promise;
    }

    // Step 2: 得到依赖的模块
    var dependencies = metaAst.dependencies;
    var contents = [];
    var readContentFromCacheDeferred = function() {
        var deferred = Q.defer();
        process.nextTick(function() {
            deferred.resolve(self.dependenciesCache[source]);
        });
        return deferred.promise;
    };
    var readContentByRealTimeDeferred = function() {
        var deferred = Q.defer();
        contents = [content];
        var dependenciesCounter = dependencies.length;

        // 文件combo完毕之后缓存
        var resolveIfLessZero = function() {
            if (dependenciesCounter <= 0) {
                if (self.options.useCache) {
                    self.dependenciesCache[source] = contents;
                }
                // fix 佛山发现的依赖库被合并了两次的bug 2014-07-16
                self.idCache[metaAst.id] = content;
                deferred.resolve(contents);
            }
        };
        resolveIfLessZero();

        _.each(dependencies, function(dependency) {
            if (_.isFunction(self.options.idExtractor)) {
                dependency = self.options.idExtractor(dependency);
            }

            var dependencyContentDeferred = null;
            if (_.has(self.idCache, dependency)) {
                dependencyContentDeferred = self.readContentFromCache(dependency);
            }
            else if (dependency.indexOf("../") === 0 || dependency.indexOf("./") === 0) {
                dependencyContentDeferred = self.readContentForRelativePath(dependency, path.dirname(source));
            }
            else {
                dependencyContentDeferred = self.readContentFromLocal(dependency);
            }

            dependencyContentDeferred.then(function(dependencyContent) {
                if (dependencyContent) {
                    contents.push(dependencyContent);
                }
            }).finally(function() {
                dependenciesCounter -= 1;
                resolveIfLessZero();
            });
        });
        return deferred.promise;
    };

    /* combo依赖文件 */
    var readContentDeferred = null;
    if (self.options.useCache && self.dependenciesCache.hasOwnProperty(source)) {
        readContentDeferred = readContentFromCacheDeferred();
    }
    else {
        readContentDeferred = readContentByRealTimeDeferred();
    }
    readContentDeferred.then(function(contents) {
        contents = _.map(contents, function(content) {
            return StringUtils.rstrip(content, {source: ";"});
        });
        contents = contents.join((self.options.separator || ";") + "\n");
        contents = StringUtils.rstrip(contents, {source: ";"}) + (self.options.separator || ";");
        deferred.resolve(contents);
    }).fail(function() {
        deferred.reject();
    });

    return deferred.promise;
};

Concat.prototype.readContentFromCache = function(id) {
    var self = this;
    var deferred = Q.defer();
    process.nextTick(function() {
        deferred.resolve(self.idCache[id]);
    });
    return deferred.promise;
};

Concat.prototype.transportFile = function(filePath, id) {
    var deferred = Q.defer();
    var self = this;
    var extName = path.extname(filePath);
    var transportConfig = {};
    extend(true, transportConfig, self.options.transportConfig);
    transportConfig.idRule = function(name) {
        return id;
    };

    if (!transportConfig.parsers.hasOwnProperty(extName)) {
        process.nextTick(function() {
            deferred.reject();
        });
    }

    try{
        var Parser = transportConfig.parsers[extName];
        var parser = new Parser(transportConfig);
        parser.execute({
            src: filePath,
            content: fs.readFileSync(filePath, "utf-8")
        }).then(function(code) {
            deferred.resolve(code);
        });
    }catch(e){
        process.nextTick(function() {
            deferred.reject(e);
        });
    }

    return deferred.promise;
};

Concat.prototype.readContentForRelativePath = function(id, dirName) {
    var deferred = Q.defer();
    var self = this;
    var newPath = path.normalize(path.join(dirName, id));
    var handle = function(content) {
        var cmdParser = new CmdParser();
        var ast = cmdParser.getAst(content);
        if (!ast || ast.error) {
            return;
        }
        var metaAst = cmdParser.parseFirst(ast);
        if (!metaAst) {
            return;
        }
        self.idCache[metaAst.id] = content;
    };

    if (!fs.existsSync(newPath) && !fs.existsSync(newPath + ".js")) {
        process.nextTick(function() {
            deferred.reject();
        });
        return deferred.promise;
    }
    var extName = path.extname(newPath);
    var fakeFilePath = newPath;
    if (extName !== ".js") {
        fakeFilePath = newPath + ".js";
    }
    if (!fs.existsSync(fakeFilePath)) {
        self.transportFile(newPath, id).then(function(content) {
            handle(content);
            deferred.resolve(content);
        }).fail(function() {
            deferred.reject();
        });
    }
    else {
        var content = fs.readFileSync(fakeFilePath, "utf-8");
        handle(content);
        deferred.resolve(content);
    }
    return deferred.promise;
};

Concat.prototype.readContentFromLocal = function(id) {
    var deferred = Q.defer();
    var self = this;
    var handle = function(content) {
        var metaAst = null;
        if (self.options.useCache && self.astCache.hasOwnProperty(file) &&
            self.astCache[file].metaAst
            ) {
            metaAst = self.astCache[file].metaAst;
        }
        else {
            var cmdParser = new CmdParser();
            var ast = cmdParser.getAst(content);
            if (!ast || ast.error) {
                return;
            }
            metaAst = cmdParser.parseFirst(ast);
            if (metaAst && self.options.useCache) {
                self.astCache[file] = {
                    ast: ast,
                    metaAst: metaAst
                };
            }
        }
        if (!metaAst) {
            return;
        }
        self.idCache[metaAst.id] = content;
    };
    var file = null;
    _.some(self.options.paths, function(p) {
        var newFile = path.join(p, id);
        if (!/\.js$/.test(newFile)) {
            newFile += ".js";
        }
        if (fs.existsSync(newFile)) {
            file = newFile;
            return true;
        }
        return false;
    });
    if (!file) {
        _.some(self.options.paths, function(p) {
            var newFile = path.join(p, id);
            if (fs.existsSync(newFile)) {
                file = newFile;
                return true;
            }
            return false;
        });
    }
    if (!file) {
        process.nextTick(function() {
            deferred.reject();
        });
        return deferred.promise;
    }
    file = path.normalize(fs.realpathSync(file));
    var extName = path.extname(file);
    var fakeFilePath = file;
    if (extName !== ".js") {
        fakeFilePath = file + ".js";
    }
    if (!fs.existsSync(fakeFilePath)) {
        self.transportFile(file, id).then(function(content) {
            handle(content);
            deferred.resolve(content);
        }).fail(function() {
            deferred.reject();
        });
    }
    else {
        var content = fs.readFileSync(fakeFilePath, "utf-8");
        handle(content);
        deferred.resolve(content);
    }
    return deferred.promise;
};

module.exports = Concat;